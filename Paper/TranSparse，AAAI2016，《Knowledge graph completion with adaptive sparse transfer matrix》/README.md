本文记录了有关TranSparse《Knowledge Graph Completion with Adaptive Sparse Transfer Matrix》论文的相关情况，如果有做相关内容的同学可以邮件与我联系 zhaoliang19960421@outlook.com

# 背景
之前的基于翻译模型中，将所有的关系是按照同一个标准来进行翻译，没有考虑关系在链接实体上的特性，在论文中将这种由于关系在链接实体上的不同，定义成了两个问题，异构性和平衡性
![1](https://note.youdao.com/yws/public/resource/f97529f58c24ed5763a838a3bf7976d1/xmlnote/9B0365A52E3A427B996C2C2CF4D71479/3903)

- 异构性：不同的关系链接的头尾对儿的个数不一样
实际的情况中，一个关系链接的头尾对儿的数量决定了这个关系在图谱中的重要性，越重要的关系就需要更多的信息来表征。如果所有的关系的重要性认为是一样的时候，就会出现重要的关系表征能力不够（欠拟合），不重要的关系添加了太多不必要的表征内容（过拟合）。因此要对不同重要性的关系进行不同程度的表征

- 平衡性：同一个关系链接的头实体和尾实体的个数也不一样
同一个关系中头尾实体的个数不同，决定了这个关系更加关注于头实体或者尾实体。和上面的异构性含义一样，更加关系的内容，就需要用更多的语义信息来表征；如果将头实体和尾实体认为是一样的重要性，也会出现重要的内容表征能力不够（欠），不重要的内容含有更多的语义内容造成了噪音（过）

# 思路
基于对以上两个问题的思考，TransSparse是基于TransD的基础上来进行修改的(TranD和这篇论文是同一个作者)，主要修改的地方是对于从实体空间到关系空间的映射矩阵的修改。
在TransD中，同一个关系的使用的是同一个映射矩阵，是不能来区分关系的重要性（异构性），关系中的头尾实体在TransD
中使用了不同的映射矩阵，但是没有加入关系重要性这个内容。
基于以上的思路，TranSparse的操作是定义了一个稀疏矩阵，稀疏矩阵的稀疏性来表示关系的重要性（异构性），每次更新映射矩阵的时候只更新非0元素，用非0元素来计算从实体空间到关系空间的映射。稀疏矩阵非0元素的位置，论文中给出了两种做法，结构性和非结构性,其中结构性的最终结果要好于非结构性

![1](https://note.youdao.com/yws/public/resource/f97529f58c24ed5763a838a3bf7976d1/xmlnote/AAFCF9B08BE84770984A5D4CEC2E5495/3905)

结构型的稀疏矩阵就是将非0元素依次的排列在对称轴两边，非结构型的稀疏矩阵就是随机放置非0元素

# 具体操作
论文中的映射矩阵稀疏性也就是关系的重要性程度用$\theta$表示，设定了一个超参数来表示重要性最小的矩阵的稀疏性（重要性最小也就是该关系链接的实体对儿最少）$\theta_{min}$，然后其它矩阵的稀疏性用以下公式计算

![1](https://note.youdao.com/yws/public/resource/f97529f58c24ed5763a838a3bf7976d1/xmlnote/AF0C9746E6654E3E96D57A38595A6C05/3907)

其中N表示对应矩阵的实体对儿个数。
在计算得到了矩阵的稀疏性之后，生成关系的稀疏映射矩阵$M(\theta_r)$,在论文中给出了俩中方式的生成方法，在进行迭代计算时只跟新非0元素

![1](https://note.youdao.com/yws/public/resource/f97529f58c24ed5763a838a3bf7976d1/xmlnote/94BD4B5631B34D80885BA5484ED4B437/3909)

    具体的构造稀疏映射矩阵时，先计算非0元素的个数，具体的计算方式就是稀疏系数*维度平方，初始化的时候在一个对角的单位矩阵上，如果对角矩阵的维度大于了要有的非0元素的个数，那么初始化的映射矩阵就是对角单位阵，如果还有剩余的元素，会按照结构型和非结构型进行安排非0元素。
    结构型的稀疏矩阵就是沿着对角线依次的随机初始化非0元素，如果剩余的个数并不是恰好能够满足沿着对角线的设置就稍微更改下下非0元的个数；非结构型就是完全随机的初始化。
在得到了映射矩阵之后，就需要计算从实体空间到关系空间的映射，在此论文分成了两个部分，共享型和独立型

![1](https://note.youdao.com/yws/public/resource/f97529f58c24ed5763a838a3bf7976d1/xmlnote/4E57E0D973744788B124F5B6CD98D5CE/3911)

共享型就是头尾实体共享一个映射矩阵，独立型就是头实体单独计算一个稀疏映射矩阵，尾实体单独计算一个映射矩阵，计算及生成方式和之前的是一样的。

之后的计算方式和其它的Trans的思路就一样了，也是计算的正负三元组的势能差。

# 代码
我没有在网上找到有关TranSparse（以及TransD）的代码，如果您手里有相关的代码（python语言的，tf或者pythorch框架的），如果方便分享的话，还麻烦您邮件和我联系 zhaoliang19960421@outlook.com